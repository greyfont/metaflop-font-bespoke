%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                                                         %%%
%%% Transit v1.6 Ð a Metaflop-Font                                          %%%
%%% © 2012 by Simon Egli, Marco MŸller, Teofilo Furtado                     %%%
%%% www.metaflop.com                                                        %%%
%%%                                                                         %%%
%%% This program is free software: you can redistribute it and/or modify    %%%
%%% it under the terms of the GNU General Public License as published by    %%%
%%% the Free Software Foundation, either version 3 of the License, or       %%%
%%% (at your option) any later version.                                     %%%
%%%                                                                         %%%
%%% This program is distributed in the hope that it will be useful,         %%%
%%% but WITHOUT ANY WARRANTY; without even the implied warranty of          %%% 
%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            %%% 
%%% GNU General Public License for more details.                            %%%
%%%                                                                         %%%
%%% You should have received a copy of the GNU General Public License       %%%
%%% along with this program. If not, see <http://www.gnu.org/licenses/>.    %%%
%%%                                                                         %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Aditional parameters / hidden parameter list
barheight#:=bar*cap#;	% Cross Bar (Upper)
leftstemloc#:=0.2u#+s#+((cont*px#)/2);	% position of left stem
letter_fit#:=0.0u#; % amount of letter fit
shrink_fit:=.0u#;  % amount of shrink fit

% definition of left and right-side bearings. To use in glyph after beginchar: normal_adjust_fit(-1.5u#,-1.5u#);
 def normal_adjust_fit(expr left_adjustment,right_adjustment) = 
 l := -hround(left_adjustment*hppp)-letter_fit#; 
 interim xoffset := -l; charwd := charwd+2letter_fit#+left_adjustment+right_adjustment; 
 r := l+hround(charwd*hppp)-shrink_fit;
 w := r-hround(right_adjustment*hppp)-letter_fit#; enddef;
%

mode=luxo;

 def makebox(text r) = 

 % for y=0,h.o_,-d.o_: r((-(.5*539-.5w); endfor % horizontals 
 
%  for y=0,h.o_,-d.o_: r((-(.5*539-.5w),y),(w+(.5*539-.5w),y)); endfor % horizontals 
 
 for y=0,h.o_,-d.o_: r((-(.5*539-.5w),-y),(w+(.5*539-.5w),y)); endfor % horizontals 

  
 % for x=0,w:	r((x,-d.o_),(x,h.o_)); endfor % verticals 
 if charic<>0: r((w+charic*hppp,h.o_),(w+charic*hppp,.5h.o_)); fi 
 enddef;

mode_setup;

%pixel conversions
% metafont needs these pixel definitions to calculate the final dimensions of the parameter values
define_pixels(s,u);
define_blacker_pixels(px,py);
define_good_x_pixels(leftstemloc, letter_fit);
define_good_y_pixels(asc);
define_good_y_pixels(des);
define_good_y_pixels(cap);
define_good_y_pixels(mean);
define_good_y_pixels(corner);
define_corrected_pixels(o);

% Begin Charater macro
def beginadjchar(expr code, unit_width, h, d) =
 beginchar(code,unit_width*u#+s#,h,d);
pickup adj_pen;
enddef;

def beginadjichar(expr code, unit_width, h, d) =
 beginchar(code,2(unit_width*u#+s#+(cont*px#)/2),h,d);
pickup adj_pen;
enddef;

% Box correction above incx .5

if (incx > .5):
corr:=(1-incx)+.5;
else: corr:=1;
fi

%Fixed pen settings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pickup pencircle xscaled px yscaled py rotated 15;
adj_pen:=savepen;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Pen angle macros
def angledpen(expr a,b)=
-(90-((180-(angle(a-b)))/2))   enddef; 

streightpensize:=contrst*px;
serif:=serifsize*u;

def verticalpensize(expr a,b)=
contrst*px/sind (90-(-(90-((180-angle(a-b))/2)) ))*sind 90 enddef;

def incxb=
incx/sind 90*sind 56 enddef;

def incxs=
incx/sind 90*sind 34 enddef;

def angb =
arcsin ((1/(sind 90)*sind 56)/(incx/((incx/sind 90)*sind 56))) enddef;

vardef diag_ratio(expr a,b,y,c) =
numeric aa_, bb_, cc_; bb_=b/y; cc_=c/y; aa_=a*a-bb_*bb_;
(a*(cc_++sqrt aa_)-bb_*cc_)/aa_ enddef;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Superness macros
%%Left curves (superness)
def super_quarterl(suffix i,j,k) =
 z.i{0,y.j-y.i}
...(superness[x.j,x.i],superness[y.i,y.j]){z.j-z.i}
...z.j{x.k-x.i,0} enddef;

%%Right curves (superness)
def super_quarterr(suffix i,j,k) =
z.j{x.k-x.i,0}
...(superness[x.j,x.k],superness[y.k,y.j]){z.k-z.j}
...z.k{0,y.k-y.j} enddef;


def super_ql(suffix i,j) =
 z.i{0,y.j-y.i}
...(superness[x.j,x.i],superness[y.i,y.j]){z.j-z.i}...z.j{x.j-x.i,0} enddef;

%%Right curves (superness)
def super_qr(suffix j,k) =
z.j{x.k-x.j,0}
...(superness[x.j,x.k],superness[y.k,y.j]){z.k-z.j}
...z.k{0,y.k-y.j} enddef;

%%Right interior curves (superness)
def super_quarterri(suffix i,j,k) =
z.j{x.k-x.i,0}
...(supernessi[x.j,x.k],supernessi[y.k,y.j]){z.k-z.j}
...z.k{0,y.k-y.j} enddef;

%%Left interior curves (superness)
def super_quarterli(suffix i,j,k) =
 z.i{0,y.j-y.i}
...(supernessi[x.j,x.i],supernessi[y.i,y.j]){z.j-z.i}
...z.j{x.k-x.i,0} enddef;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Glyph inputs:
input glyphs/A
input glyphs/B
input glyphs/C
input glyphs/D
input glyphs/E
input glyphs/F
input glyphs/G
input glyphs/H
input glyphs/I 
input glyphs/J
input glyphs/K
input glyphs/L
input glyphs/M
input glyphs/N
input glyphs/O
input glyphs/P
input glyphs/Q
input glyphs/R
input glyphs/S
input glyphs/T
input glyphs/U
input glyphs/V
input glyphs/W
input glyphs/X
input glyphs/Y
input glyphs/Z
input glyphs/a_lc
input glyphs/b_lc
input glyphs/c_lc
input glyphs/d_lc
input glyphs/e_lc
input glyphs/f_lc
input glyphs/g_lc
input glyphs/h_lc
input glyphs/i_lc
input glyphs/j_lc
input glyphs/k_lc
input glyphs/l_lc
input glyphs/m_lc
input glyphs/n_lc
input glyphs/o_lc
input glyphs/p_lc
input glyphs/q_lc
input glyphs/r_lc
input glyphs/s_lc
input glyphs/t_lc
input glyphs/u_lc
input glyphs/v_lc
input glyphs/w_lc
input glyphs/x_lc
input glyphs/y_lc
input glyphs/z_lc
input glyphs/8

% input glyphs/cifrao
input glyphs/comma
input glyphs/dot
input glyphs/excl

font_quad:=10u#+0s#;
font_normal_space:=4u#+.2s#;
font_normal_stretch:=0u#;
font_normal_shrink:=0u#;

ligtable "A": 
"C" kern -0.3u#, "G" kern -0.3u#, "O" kern -0.3u#, "Q" kern -0.3u#, 
"S" kern -0.2u#, "T" kern -0.7u#, "U" kern -0.1u#, 
"V" kern -0.5u#, "W" kern -0.5u#, "Y" kern -0.5u#,
"c" kern -0.2u#, "d" kern -0.2u#, "e" kern -0.2u#, 
"o" kern -0.2u#, "q" kern -0.2u#,
"s" kern -0.1u#, "t" kern -0.5u#, "u" kern -0.1u#, 
"v" kern -0.5u#, "w" kern -0.5u#, "y" kern -0.5u#;
% ligtable "O": "Q": "D": 
% "V" kern -0.3u#, "W" kern -0.3u#, "X" kern -0.3u#, "Y" kern -0.3u#, "Z" kern -0.3u#;

% ligtable "L": "O" =: oct"014";   % USE THIS FOR LIGATURES OR SPECIAL CHARACTERS
% ligtable "o": "b": "p": "e" kern .5u#, "o" kern .5u#, "x" kern-.5u#, % page 316 MetaFontBook
%font_identifier:="FRAN" if slant<>0: & "SL" fi;
%font_coding_scheme:="ABCDEFGHIJKLMNOPQRSTUVWXYZ only";

if known ps_output:

font_coding_scheme	"ot1";
font_comment	"Copyright (C) 2012 MetaFlop";
font_family	"Fontname";	
font_fixed_pitch	false;
font_identifier	"Fontname Light Oblique";
font_name			"Fontname-LightOblique";
font_size			10pt;
%font_slant		1/6;
font_underline_position	-1pt#;
font_underline_thickness	1/2pt#;
%font_unique_id		"4112233";
font_version		"002.005";
font_weight		"Light";

fi
